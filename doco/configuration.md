<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /doco/mdsource/configuration.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# Configuration

<!-- toc -->
## Contents

  * [Container Registration](#container-registration)
    * [Inputs](#inputs)
    * [Usage](#usage)
  * [DocumentExecuter](#documentexecuter)
  * [Connection Types](#connection-types)
  * [DependencyInjection and ASP.Net Core](#dependencyinjection-and-aspnet-core)
  * [Multiple DbContexts](#multiple-dbcontexts)
    * [UserContext](#usercontext)
    * [Register in container](#register-in-container)
    * [ExecutionOptions](#executionoptions)
    * [Query](#query)
    * [GraphType](#graphtype)
  * [Testing the GraphQlController](#testing-the-graphqlcontroller)
  * [GraphQlExtensions](#graphqlextensions)
    * [ExecuteWithErrorCheck](#executewitherrorcheck)
  * [EF Core TPH and GraphQL Interface](#ef-core-tph-and-graphql-interface)
    * [EF Core Entities](#ef-core-entities)
    * [GraphQL types](#graphql-types)
    * [GraphQL query](#graphql-query)<!-- endtoc -->


## Container Registration

Enabling is done via registering in a container.

The container registration can be done via adding to a [IServiceCollection](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.iservicecollection):

<!-- snippet: RegisterInContainer -->
<a id='snippet-registerincontainer'></a>
```cs
public static void RegisterInContainer<TDbContext>(
        IServiceCollection services,
        ResolveDbContext<TDbContext>? resolveDbContext = null,
        IModel? model = null,
        ResolveFilters? resolveFilters = null)
```
<sup><a href='/src/GraphQL.EntityFramework/EfGraphQLConventions.cs#L18-L24' title='File snippet `registerincontainer` was extracted from'>snippet source</a> | <a href='#snippet-registerincontainer' title='Navigate to start of snippet `registerincontainer`'>anchor</a></sup>
<a id='snippet-registerincontainer-1'></a>
```cs
EfGraphQLConventions.RegisterInContainer<MyDbContext>(
    serviceCollection,
    model: ModelBuilder.GetInstance());
```
<sup><a href='/src/Snippets/Configuration.cs#L23-L27' title='File snippet `registerincontainer` was extracted from'>snippet source</a> | <a href='#snippet-registerincontainer-1' title='Navigate to start of snippet `registerincontainer`'>anchor</a></sup>
<!-- endsnippet -->


### Inputs


#### IModel

Configuration requires an instance of `Microsoft.EntityFrameworkCore.Metadata.IModel`. This can be passed in as a parameter, or left as null to be resolved from the container. When `IModel` is resolved from the container, `IServiceProvider.GetService` is called first on `IModel`, then on `TDbContext`. If both return null, then an exception will be thrown.

To build an instance of an `IModel` at configuration time it can be helpful to have a class specifically for that purpose:

<!-- snippet: ModelBuilder -->
<a id='snippet-modelbuilder'></a>
```cs
static class ModelBuilder
{
    public static IModel GetInstance()
    {
        var builder = new DbContextOptionsBuilder();
        builder.UseSqlServer("Fake");
        using var context = new MyDbContext(builder.Options);
        return context.Model;
    }
}
```
<sup><a href='/src/Snippets/Configuration.cs#L8-L19' title='File snippet `modelbuilder` was extracted from'>snippet source</a> | <a href='#snippet-modelbuilder' title='Navigate to start of snippet `modelbuilder`'>anchor</a></sup>
<!-- endsnippet -->


#### Resolve DbContext

A delegate that resolves the DbContext.

<!-- snippet: ResolveDbContext.cs -->
<a id='snippet-ResolveDbContext.cs'></a>
```cs
using Microsoft.EntityFrameworkCore;

namespace GraphQL.EntityFramework
{
    public delegate TDbContext ResolveDbContext<out TDbContext>(object userContext)
        where TDbContext : DbContext;
}
```
<sup><a href='/src/GraphQL.EntityFramework/GraphApi/ResolveDbContext.cs#L1-L7' title='File snippet `ResolveDbContext.cs` was extracted from'>snippet source</a> | <a href='#snippet-ResolveDbContext.cs' title='Navigate to start of snippet `ResolveDbContext.cs`'>anchor</a></sup>
<!-- endsnippet -->

It has access to the current GraphQL user context.

If null then the DbContext will be resolved from the container.


#### Resolve Filters

A delegate that resolves the [Filters](filters.md).

<!-- snippet: ResolveFilters.cs -->
<a id='snippet-ResolveFilters.cs'></a>
```cs
namespace GraphQL.EntityFramework
{
    public delegate Filters? ResolveFilters(object userContext);
}
```
<sup><a href='/src/GraphQL.EntityFramework/Filters/ResolveFilters.cs#L1-L4' title='File snippet `ResolveFilters.cs` was extracted from'>snippet source</a> | <a href='#snippet-ResolveFilters.cs' title='Navigate to start of snippet `ResolveFilters.cs`'>anchor</a></sup>
<!-- endsnippet -->

It has access to the current GraphQL user context.

If null then the Filters will be resolved from the container.


### Usage

<!-- snippet: RegisterInContainer -->
<a id='snippet-registerincontainer'></a>
```cs
public static void RegisterInContainer<TDbContext>(
        IServiceCollection services,
        ResolveDbContext<TDbContext>? resolveDbContext = null,
        IModel? model = null,
        ResolveFilters? resolveFilters = null)
```
<sup><a href='/src/GraphQL.EntityFramework/EfGraphQLConventions.cs#L18-L24' title='File snippet `registerincontainer` was extracted from'>snippet source</a> | <a href='#snippet-registerincontainer' title='Navigate to start of snippet `registerincontainer`'>anchor</a></sup>
<a id='snippet-registerincontainer-1'></a>
```cs
EfGraphQLConventions.RegisterInContainer<MyDbContext>(
    serviceCollection,
    model: ModelBuilder.GetInstance());
```
<sup><a href='/src/Snippets/Configuration.cs#L23-L27' title='File snippet `registerincontainer` was extracted from'>snippet source</a> | <a href='#snippet-registerincontainer-1' title='Navigate to start of snippet `registerincontainer`'>anchor</a></sup>
<!-- endsnippet -->

Then the `IEfGraphQLService` can be resolved via [dependency injection in GraphQL.net](https://graphql-dotnet.github.io/docs/guides/advanced#dependency-injection) to be used in `ObjectGraphType`s when adding query fields.


## DocumentExecuter

The default GraphQL `DocumentExecuter` uses [Task.WhenAll](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.whenall) to resolve async fields. This can result in multiple EF queries being executed on different threads and being resolved out of order. In this scenario the following exception will be thrown.

> Message: System.InvalidOperationException : A second operation started on this context before a previous operation completed. This is usually caused by different threads using the same instance of DbContext, however instance members are not guaranteed to be thread safe. This could also be caused by a nested query being evaluated on the client, if this is the case rewrite the query avoiding nested invocations.

To avoid this a custom implementation of `DocumentExecuter` but be used that uses `SerialExecutionStrategy` when the operation type is `OperationType.Query`. There is one included in this library named `EfDocumentExecuter`:

<!-- snippet: EfDocumentExecuter.cs -->
<a id='snippet-EfDocumentExecuter.cs'></a>
```cs
using GraphQL.Execution;
using GraphQL.Language.AST;

namespace GraphQL.EntityFramework
{
    public class EfDocumentExecuter :
        DocumentExecuter
    {
        protected override IExecutionStrategy SelectExecutionStrategy(ExecutionContext context)
        {
            Guard.AgainstNull(nameof(context), context);
            if (context.Operation.OperationType == OperationType.Query)
            {
                return new SerialExecutionStrategy();
            }
            return base.SelectExecutionStrategy(context);
        }
    }
}
```
<sup><a href='/src/GraphQL.EntityFramework/EfDocumentExecuter.cs#L1-L19' title='File snippet `EfDocumentExecuter.cs` was extracted from'>snippet source</a> | <a href='#snippet-EfDocumentExecuter.cs' title='Navigate to start of snippet `EfDocumentExecuter.cs`'>anchor</a></sup>
<!-- endsnippet -->


## Connection Types

GraphQL enables paging via [Connections](https://graphql.org/learn/pagination/#complete-connection-model). When using Connections in GraphQL.net it is [necessary to register several types in the container](https://github.com/graphql-dotnet/graphql-dotnet/issues/451#issuecomment-335894433):

```csharp
services.AddTransient(typeof(ConnectionType<>));
services.AddTransient(typeof(EdgeType<>));
services.AddSingleton<PageInfoType>();
```

There is a helper methods to perform the above:

```csharp
EfGraphQLConventions.RegisterConnectionTypesInContainer(IServiceCollection services);
```

or

```csharp
EfGraphQLConventions.RegisterConnectionTypesInContainer(Action<Type> register)
```


## DependencyInjection and ASP.Net Core

As with GraphQL .net, GraphQL.EntityFramework makes no assumptions on the container or web framework it is hosted in. However given [Microsoft.Extensions.DependencyInjection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection) and [ASP.Net Core](https://docs.microsoft.com/en-us/aspnet/core/) are the most likely usage scenarios, the below will address those scenarios explicitly.

See the GraphQL .net [documentation for ASP.Net Core](https://graphql-dotnet.github.io/docs/getting-started/dependency-injection#aspnet-core) and the [ASP.Net Core sample](https://github.com/graphql-dotnet/examples/tree/master/src/AspNetCoreCustom/Example).

The Entity Framework Data Context instance is generally [scoped per request](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection#service-lifetimes-and-registration-options). This can be done in the [Startup.ConfigureServices method](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup#the-configureservices-method):

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddScoped(
          provider => MyDbContextBuilder.BuildDbContext());
    }
}
```

Entity Framework also provides [several helper methods](https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext#using-dbcontext-with-dependency-injection) to control a DbContexts lifecycle. For example:

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddDbContext<MyDbContext>(
          provider => DbContextBuilder.BuildDbContext());
    }
}
```

See also [EntityFrameworkServiceCollectionExtensions](https://docs.microsoft.com/en-us/ef/core/api/microsoft.extensions.dependencyinjection.entityframeworkservicecollectionextensions)

With the DbContext existing in the container, it can be resolved in the controller that handles the GraphQL query:

<!-- snippet: GraphQlController -->
<a id='snippet-graphqlcontroller'></a>
```cs
[Route("[controller]")]
[ApiController]
public class GraphQlController :
    Controller
{
    IDocumentExecuter executer;
    ISchema schema;

    public GraphQlController(ISchema schema, IDocumentExecuter executer)
    {
        this.schema = schema;
        this.executer = executer;
    }

    [HttpPost]
    public Task<ExecutionResult> Post(
        [BindRequired, FromBody] PostBody body,
        CancellationToken cancellation)
    {
        return Execute(body.Query, body.OperationName, body.Variables, cancellation);
    }

    public class PostBody
    {
        public string? OperationName;
        public string Query = null!;
        public JObject? Variables;
    }

    [HttpGet]
    public Task<ExecutionResult> Get(
        [FromQuery] string query,
        [FromQuery] string? variables,
        [FromQuery] string? operationName,
        CancellationToken cancellation)
    {
        var jObject = ParseVariables(variables);
        return Execute(query, operationName, jObject, cancellation);
    }

    async Task<ExecutionResult> Execute(string query,
        string? operationName,
        JObject? variables,
        CancellationToken cancellation)
    {
        var options = new ExecutionOptions
        {
            Schema = schema,
            Query = query,
            OperationName = operationName,
            Inputs = variables?.ToInputs(),
            CancellationToken = cancellation,
#if (DEBUG)
            ExposeExceptions = true,
            EnableMetrics = true,
#endif
        };
        var executeAsync = await executer.ExecuteAsync(options);

        return new ExecutionResult
        {
            Data = executeAsync.Data,
            Errors = executeAsync.Errors
        };
    }

    static JObject? ParseVariables(string? variables)
    {
        if (variables == null)
        {
            return null;
        }

        try
        {
            return JObject.Parse(variables);
        }
        catch (Exception exception)
        {
            throw new Exception("Could not parse variables.", exception);
        }
    }
}
```
<sup><a href='/src/SampleWeb/GraphQlController.cs#L11-L95' title='File snippet `graphqlcontroller` was extracted from'>snippet source</a> | <a href='#snippet-graphqlcontroller' title='Navigate to start of snippet `graphqlcontroller`'>anchor</a></sup>
<!-- endsnippet -->


## Multiple DbContexts

Multiple different DbContext types can be registered and used.


### UserContext

A user context that exposes both types.

<!-- snippet: MultiUserContext -->
<a id='snippet-multiusercontext'></a>
```cs
public class UserContext: Dictionary<string, object>
{
    public UserContext(DbContext1 context1, DbContext2 context2)
    {
        DbContext1 = context1;
        DbContext2 = context2;
    }

    public readonly DbContext1 DbContext1;
    public readonly DbContext2 DbContext2;
}
```
<sup><a href='/src/Tests/MultiContextTests/MultiContextTests.cs#L96-L108' title='File snippet `multiusercontext` was extracted from'>snippet source</a> | <a href='#snippet-multiusercontext' title='Navigate to start of snippet `multiusercontext`'>anchor</a></sup>
<!-- endsnippet -->


### Register in container

Register both DbContext types in the container and include how those instance can be extracted from the GraphQL context:

<!-- snippet: RegisterMultipleInContainer -->
<a id='snippet-registermultipleincontainer'></a>
```cs
EfGraphQLConventions.RegisterInContainer(
    services,
    userContext => ((UserContext) userContext).DbContext1);
EfGraphQLConventions.RegisterInContainer(
    services,
    userContext => ((UserContext) userContext).DbContext2);
```
<sup><a href='/src/Tests/MultiContextTests/MultiContextTests.cs#L64-L73' title='File snippet `registermultipleincontainer` was extracted from'>snippet source</a> | <a href='#snippet-registermultipleincontainer' title='Navigate to start of snippet `registermultipleincontainer`'>anchor</a></sup>
<!-- endsnippet -->


### ExecutionOptions

Use the user type to pass in both DbContext instances.


<!-- snippet: MultiExecutionOptions -->
<a id='snippet-multiexecutionoptions'></a>
```cs
var executionOptions = new ExecutionOptions
{
    Schema = schema,
    Query = query,
    UserContext = new UserContext(dbContext1, dbContext2)
};
```
<sup><a href='/src/Tests/MultiContextTests/MultiContextTests.cs#L79-L88' title='File snippet `multiexecutionoptions` was extracted from'>snippet source</a> | <a href='#snippet-multiexecutionoptions' title='Navigate to start of snippet `multiexecutionoptions`'>anchor</a></sup>
<!-- endsnippet -->


### Query

Use both DbContexts in a Query:

<!-- snippet: MultiContextQuery.cs -->
<a id='snippet-MultiContextQuery.cs'></a>
```cs
using GraphQL.EntityFramework;
using GraphQL.Types;

public class MultiContextQuery :
    ObjectGraphType
{
    public MultiContextQuery(
        IEfGraphQLService<DbContext1> efGraphQlService1,
        IEfGraphQLService<DbContext2> efGraphQlService2)
    {
        efGraphQlService1.AddSingleField(
            graph: this,
            name: "entity1",
            resolve: context =>
            {
                var userContext = (UserContext) context.UserContext;
                return userContext.DbContext1.Entities;
            });
        efGraphQlService2.AddSingleField(
            graph: this,
            name: "entity2",
            resolve: context =>
            {
                var userContext = (UserContext) context.UserContext;
                return userContext.DbContext2.Entities;
            });
    }
}
```
<sup><a href='/src/Tests/MultiContextTests/MultiContextQuery.cs#L1-L28' title='File snippet `MultiContextQuery.cs` was extracted from'>snippet source</a> | <a href='#snippet-MultiContextQuery.cs' title='Navigate to start of snippet `MultiContextQuery.cs`'>anchor</a></sup>
<!-- endsnippet -->


### GraphType

Use a DbContext in a Graph:

<!-- snippet: Entity1Graph.cs -->
<a id='snippet-Entity1Graph.cs'></a>
```cs
using GraphQL.EntityFramework;

public class Entity1Graph :
    EfObjectGraphType<DbContext1, Entity1>
{
    public Entity1Graph(IEfGraphQLService<DbContext1> graphQlService) :
        base(graphQlService)
    {
        AutoMap();
    }
}
```
<sup><a href='/src/Tests/MultiContextTests/Graphs/Entity1Graph.cs#L1-L11' title='File snippet `Entity1Graph.cs` was extracted from'>snippet source</a> | <a href='#snippet-Entity1Graph.cs' title='Navigate to start of snippet `Entity1Graph.cs`'>anchor</a></sup>
<!-- endsnippet -->


## Testing the GraphQlController

The `GraphQlController` can be tested using the [ASP.NET Integration tests](https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests) via the [Microsoft.AspNetCore.Mvc.Testing NuGet package](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Testing).

<!-- snippet: GraphQlControllerTests -->
<a id='snippet-graphqlcontrollertests'></a>
```cs
[UsesVerify]
public class GraphQlControllerTests
{
    static HttpClient client = null!;
    static WebSocketClient websocketClient = null!;

    static GraphQlControllerTests()
    {
        var server = GetTestServer();
        client = server.CreateClient();
        websocketClient = server.CreateWebSocketClient();
        websocketClient.ConfigureRequest =
            request =>
            {
                var headers = request.Headers;
                headers["Sec-WebSocket-Protocol"] = "graphql-ws";
            };
    }

    [Fact]
    public async Task Get()
    {
        var query = @"
{
  companies
  {
    id
  }
}";
        using var response = await ClientQueryExecutor.ExecuteGet(client, query);
        response.EnsureSuccessStatusCode();
        await Verifier.Verify(await response.Content.ReadAsStringAsync());
    }

    [Fact]
    public async Task Get_single()
    {
        var query = @"
query ($id: ID!)
{
  company(id:$id)
  {
    id
  }
}";
        var variables = new
        {
            id = "1"
        };

        using var response = await ClientQueryExecutor.ExecuteGet(client, query, variables);
        response.EnsureSuccessStatusCode();
        await Verifier.Verify(await response.Content.ReadAsStringAsync());
    }

    [Fact]
    public async Task Get_single_not_found()
    {
        var query = @"
query ($id: ID!)
{
  company(id:$id)
  {
    id
  }
}";
        var variables = new
        {
            id = "99"
        };

        using var response = await ClientQueryExecutor.ExecuteGet(client, query, variables);
        var result = await response.Content.ReadAsStringAsync();
        Assert.Contains("Not found", result);
    }

    [Fact]
    public async Task Get_variable()
    {
        var query = @"
query ($id: ID!)
{
  companies(ids:[$id])
  {
    id
  }
}";
        var variables = new
        {
            id = "1"
        };

        using var response = await ClientQueryExecutor.ExecuteGet(client, query, variables);
        response.EnsureSuccessStatusCode();
        await Verifier.Verify(await response.Content.ReadAsStringAsync());
    }

    [Fact]
    public async Task Get_companies_paging()
    {
        var after = 1;
        var query = @"
query {
  companiesConnection(first:2, after:""" + after + @""") {
    edges {
      cursor
      node {
        id
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}";
        using var response = await ClientQueryExecutor.ExecuteGet(client, query);
        response.EnsureSuccessStatusCode();
        await Verifier.Verify(await response.Content.ReadAsStringAsync());
    }

    [Fact]
    public async Task Get_employee_summary()
    {
        var query = @"
query {
  employeeSummary {
    companyId
    averageAge
  }
}";
        using var response = await ClientQueryExecutor.ExecuteGet(client, query);
        response.EnsureSuccessStatusCode();
        await Verifier.Verify(await response.Content.ReadAsStringAsync());
    }

    [Fact]
    public async Task Get_complex_query_result()
    {
        var query = @"
query {
  employees (
    where: [
      {groupedExpressions: [
        {path: ""content"", comparison: ""contains"", value: ""4"", connector: ""or""},

          { path: ""content"", comparison: ""contains"", value: ""2""}
      ], connector: ""and""},
      {path: ""age"", comparison: ""greaterThanOrEqual"", value: ""31""}
  	]
  ) {
    id
  }
}";
        using var response = await ClientQueryExecutor.ExecuteGet(client, query);
        var result = await response.Content.ReadAsStringAsync();
        Assert.Contains("{\"employees\":[{\"id\":3},{\"id\":5}]}", result);
        response.EnsureSuccessStatusCode();
    }

    [Fact]
    public async Task Post()
    {
        var query = @"
{
  companies
  {
    id
  }
}";
        using var response = await ClientQueryExecutor.ExecutePost(client, query);
        var result = await response.Content.ReadAsStringAsync();
        Assert.Contains(
            "{\"companies\":[{\"id\":1},{\"id\":4},{\"id\":6},{\"id\":7}]}",
            result);
        response.EnsureSuccessStatusCode();
    }

    [Fact]
    public async Task Post_variable()
    {
        var query = @"
query ($id: ID!)
{
  companies(ids:[$id])
  {
    id
  }
}";
        var variables = new
        {
            id = "1"
        };
        using var response = await ClientQueryExecutor.ExecutePost(client, query, variables);
        var result = await response.Content.ReadAsStringAsync();
        Assert.Contains("{\"companies\":[{\"id\":1}]}", result);
        response.EnsureSuccessStatusCode();
    }

    //TODO: https://github.com/graphql-dotnet/graphql-client
  //  [Fact]
//    public async Task Should_subscribe_to_companies()
//    {
//        var resetEvent = new AutoResetEvent(false);

//        var result = new GraphQLHttpSubscriptionResult(
//            new Uri("http://example.com/graphql"),
//            new GraphQLRequest
//            {
//                Query = @"
//subscription
//{
//  companyChanged
//  {
//    id
//  }
//}"
//            },
//            websocketClient,
//            response =>
//            {
//                if (response == null)
//                {
//                    return;
//                }

//                Assert.Null(response.Errors);

//                if (response.Data != null)
//                {
//                    resetEvent.Set();
//                }
//            });

//        var cancellationSource = new CancellationTokenSource();

//        var task = result.StartAsync(cancellationSource.Token);

//        Assert.True(resetEvent.WaitOne(TimeSpan.FromSeconds(10)));

//        cancellationSource.Cancel();

//        await task;
//    }

    static TestServer GetTestServer()
    {
        var hostBuilder = new WebHostBuilder();
        hostBuilder.UseStartup<Startup>();
        return new TestServer(hostBuilder);
    }
}
```
<sup><a href='/src/SampleWeb.Tests/GraphQlControllerTests.cs#L9-L265' title='File snippet `graphqlcontrollertests` was extracted from'>snippet source</a> | <a href='#snippet-graphqlcontrollertests' title='Navigate to start of snippet `graphqlcontrollertests`'>anchor</a></sup>
<!-- endsnippet -->


## GraphQlExtensions

The `GraphQlExtensions` class exposes some helper methods:


### ExecuteWithErrorCheck

Wraps the `DocumentExecuter.ExecuteAsync` to throw if there are any errors.

<!-- snippet: ExecuteWithErrorCheck -->
<a id='snippet-executewitherrorcheck'></a>
```cs
public static async Task<ExecutionResult> ExecuteWithErrorCheck(
    this IDocumentExecuter executer,
    ExecutionOptions options)
{
    Guard.AgainstNull(nameof(executer), executer);
    Guard.AgainstNull(nameof(options), options);
    var executionResult = await executer.ExecuteAsync(options);

    var errors = executionResult.Errors;
    if (errors != null && errors.Count > 0)
    {
        if (errors.Count == 1)
        {
            throw errors.First();
        }

        throw new AggregateException(errors);
    }

    return executionResult;
}
```
<sup><a href='/src/GraphQL.EntityFramework/GraphQlExtensions.cs#L9-L33' title='File snippet `executewitherrorcheck` was extracted from'>snippet source</a> | <a href='#snippet-executewitherrorcheck' title='Navigate to start of snippet `executewitherrorcheck`'>anchor</a></sup>
<!-- endsnippet -->


## EF Core TPH and GraphQL Interface

Map a [table-per-hierarchy (TPH) EF Core pattern](https://docs.microsoft.com/en-us/ef/core/modeling/inheritance) to a [GraphQL interface](https://graphql-dotnet.github.io/docs/getting-started/interfaces) to describe the shared properties in the base type, and then each type in the hierarchy to its own GraphQL type. From now on, a GraphQL query returning the interface type could be defined, allowing clients to request either common properties or specific one using [inline fragments](https://graphql.org/learn/queries/#inline-fragments).

### EF Core Entities

<!-- snippet: InheritedEntity.cs -->
<a id='snippet-InheritedEntity.cs'></a>
```cs
using System;
using System.Collections.Generic;

public abstract class InheritedEntity
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string? Property { get; set; }
    public IList<DerivedChildEntity> ChildrenFromBase { get; set; } = new List<DerivedChildEntity>();
}
```
<sup><a href='/src/Tests/IntegrationTests/Graphs/Inheritance/InheritedEntity.cs#L1-L9' title='File snippet `InheritedEntity.cs` was extracted from'>snippet source</a> | <a href='#snippet-InheritedEntity.cs' title='Navigate to start of snippet `InheritedEntity.cs`'>anchor</a></sup>
<!-- endsnippet -->

<!-- snippet: DerivedEntity.cs -->
<a id='snippet-DerivedEntity.cs'></a>
```cs

public class DerivedEntity : InheritedEntity
{
}
```
<sup><a href='/src/Tests/IntegrationTests/Graphs/Inheritance/DerivedEntity.cs#L1-L4' title='File snippet `DerivedEntity.cs` was extracted from'>snippet source</a> | <a href='#snippet-DerivedEntity.cs' title='Navigate to start of snippet `DerivedEntity.cs`'>anchor</a></sup>
<!-- endsnippet -->

### GraphQL types

<!-- snippet: InterfaceGraph.cs -->
<a id='snippet-InterfaceGraph.cs'></a>
```cs
using GraphQL.EntityFramework;

public class InterfaceGraph :
    EfInterfaceGraphType<IntegrationDbContext, InheritedEntity>
{
    public InterfaceGraph(IEfGraphQLService<IntegrationDbContext> graphQlService) :
        base(graphQlService)
    {
        Field(e => e.Id);
        Field(e => e.Property, nullable: true);
        AddNavigationConnectionField<DerivedChildEntity>(
            name: "childrenFromInterface",
            includeNames: new[] { "ChildrenFromBase" });
    }
}
```
<sup><a href='/src/Tests/IntegrationTests/Graphs/Inheritance/InterfaceGraph.cs#L1-L15' title='File snippet `InterfaceGraph.cs` was extracted from'>snippet source</a> | <a href='#snippet-InterfaceGraph.cs' title='Navigate to start of snippet `InterfaceGraph.cs`'>anchor</a></sup>
<!-- endsnippet -->

<!-- snippet: DerivedGraph.cs -->
<a id='snippet-DerivedGraph.cs'></a>
```cs
using GraphQL.EntityFramework;

public class DerivedGraph :
    EfObjectGraphType<IntegrationDbContext, DerivedEntity>
{
    public DerivedGraph(IEfGraphQLService<IntegrationDbContext> graphQlService) :
        base(graphQlService)
    {
        AddNavigationConnectionField(
            name: "childrenFromInterface",
            e => e.Source.ChildrenFromBase);
        AutoMap();
        Interface<InterfaceGraph>();
        IsTypeOf = obj => obj is DerivedEntity;
    }
}
```
<sup><a href='/src/Tests/IntegrationTests/Graphs/Inheritance/DerivedGraph.cs#L1-L16' title='File snippet `DerivedGraph.cs` was extracted from'>snippet source</a> | <a href='#snippet-DerivedGraph.cs' title='Navigate to start of snippet `DerivedGraph.cs`'>anchor</a></sup>
<!-- endsnippet -->

### GraphQL query

```csharp
efGraphQlService.AddQueryConnectionField(
    this,
    itemGraphType: typeof(InterfaceGraph),
    name: "interfaceGraphConnection",
    resolve: context => context.DbContext.InheritedEntities);
```
