<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /docs/mdsource/filters.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# Filters

Sometimes, in the context of constructing an EF query, it is not possible to know if any given item should be returned in the results. For example when performing authorization where the rules rules are pulled from a different system, and that information does not exist in the database.

`Filters` allows a custom function to be executed after the EF query execution and determine if any given node should be included in the result.

Notes:

 * When evaluated on nodes of a collection, excluded nodes will be removed from collection.
 * When evaluated on a property node, the value will be replaced with null.
 * When doing paging or counts, there is currently no smarts that adjust counts or pages sizes when items are excluded. If this is required submit a PR that adds this feature, or don't mix filters with paging.
 * The filter is passed the current [User Context](https://graphql-dotnet.github.io/docs/getting-started/user-context) and the node item instance.
 * Filters will not be executed on null item instance.
 * A [Type.IsAssignableFrom](https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom) check will be performed to determine if an item instance should be filtered based on the `<TItem>`.


### Signature:

<!-- snippet: FiltersSignature -->
<a id='snippet-FiltersSignature'></a>
```cs
public class Filters<TDbContext>
    where TDbContext : DbContext
{
    public delegate bool Filter<in TEntity>(object userContext, TDbContext data, ClaimsPrincipal? userPrincipal, TEntity input)
        where TEntity : class;

    public delegate Task<bool> AsyncFilter<in TEntity>(object userContext, TDbContext data, ClaimsPrincipal? userPrincipal, TEntity input)
        where TEntity : class;
```
<sup><a href='/src/GraphQL.EntityFramework/Filters/Filters.cs#L3-L14' title='Snippet source file'>snippet source</a> | <a href='#snippet-FiltersSignature' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Filter Projections

When filters need to access navigation properties or foreign keys that aren't included in the GraphQL query, the library provides projection-based filter overloads. These overloads allow specifying exactly which fields the filter needs, and the library will efficiently query only those fields from the database.

### Why Use Projections?

Without projections, filters receive the entity instance as loaded by the GraphQL query. If the query only selects a few fields (via EF projection), foreign keys and navigation properties may not be populated, making authorization decisions impossible.

**Benefits:**

* **Access to Foreign Keys**: Query foreign key properties even when not requested in the GraphQL query
* **Performance**: Load only the fields needed for filtering, not the entire entity
* **Explicit Dependencies**: Clearly declare what data the filter requires

**Important Requirements:**

* The entity type must have an `Id` property
* The projection is executed as a separate database query using the entity IDs
* The `Id` is automatically included in the database query even if not in the projection

### Usage:

<!-- snippet: projection-filter -->
<a id='snippet-projection-filter'></a>
```cs
public class ChildEntity
{
    public Guid Id { get; set; }
    public Guid? ParentId { get; set; }
    public string? Property { get; set; }
}

public class ChildFilterProjection
{
    public Guid? ParentId { get; set; }
}
```
<sup><a href='/src/Snippets/GlobalFilterSnippets.cs#L31-L45' title='Snippet source file'>snippet source</a> | <a href='#snippet-projection-filter' title='Start of snippet'>anchor</a></sup>
<a id='snippet-projection-filter-1'></a>
```cs
var filters = new Filters<MyDbContext>();
filters.Add<ChildEntity, ChildFilterProjection>(
    projection: child => new ChildFilterProjection
    {
        ParentId = child.ParentId
    },
    filter: (userContext, data, userPrincipal, projected) =>
    {
        var allowedParentId = GetAllowedParentId(userContext);
        return projected.ParentId == allowedParentId;
    });
EfGraphQLConventions.RegisterInContainer<MyDbContext>(
    services,
    resolveFilters: _ => filters);
```
<sup><a href='/src/Snippets/GlobalFilterSnippets.cs#L49-L66' title='Snippet source file'>snippet source</a> | <a href='#snippet-projection-filter-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

### How It Works:

1. GraphQL query executes and loads entities based on requested fields
2. For each entity, the library extracts the entity ID
3. A separate database query fetches only the projected fields using those IDs:
   ```sql
   SELECT Id, ParentId
   FROM ChildEntities
   WHERE Id IN (...)
   ```
4. The projected data is passed to the filter function
5. Entities that fail the filter are excluded from results

### Standard (Non-Projection) Filters:

For filters that only need fields already loaded by the GraphQL query:

<!-- snippet: add-filter -->
<a id='snippet-add-filter'></a>
```cs
public class MyEntity
{
    public string? Property { get; set; }
}
```
<sup><a href='/src/Snippets/GlobalFilterSnippets.cs#L5-L12' title='Snippet source file'>snippet source</a> | <a href='#snippet-add-filter' title='Start of snippet'>anchor</a></sup>
<a id='snippet-add-filter-1'></a>
```cs
var filters = new Filters<MyDbContext>();
filters.Add<MyEntity>(
    (userContext, dbContext, userPrincipal, item) => item.Property != "Ignore");
EfGraphQLConventions.RegisterInContainer<MyDbContext>(
    services,
    resolveFilters: _ => filters);
```
<sup><a href='/src/Snippets/GlobalFilterSnippets.cs#L16-L25' title='Snippet source file'>snippet source</a> | <a href='#snippet-add-filter-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->
