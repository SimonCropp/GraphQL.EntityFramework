<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /docs/mdsource/filters.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# Filters

Sometimes, in the context of constructing an EF query, it is not possible to know if any given item should be returned in the results. For example when performing authorization where the rules rules are pulled from a different system, and that information does not exist in the database.

`Filters` allows a custom function to be executed after the EF query execution and determine if any given node should be included in the result.

Notes:

 * When evaluated on nodes of a collection, excluded nodes will be removed from collection.
 * When evaluated on a property node, the value will be replaced with null.
 * When doing paging or counts, there is currently no smarts that adjust counts or pages sizes when items are excluded. If this is required submit a PR that adds this feature, or don't mix filters with paging.
 * The filter is passed the current [User Context](https://graphql-dotnet.github.io/docs/getting-started/user-context) and the node item instance.
 * Filters will not be executed on null item instance.
 * A [Type.IsAssignableFrom](https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom) check will be performed to determine if an item instance should be filtered based on the `<TItem>`.


### Signature:

<!-- snippet: FiltersSignature -->
<a id='snippet-FiltersSignature'></a>
```cs
public class Filters<TDbContext>
    where TDbContext : DbContext
{
    public delegate bool Filter<in TEntity>(object userContext, TDbContext data, ClaimsPrincipal? userPrincipal, TEntity input);

    public delegate Task<bool> AsyncFilter<in TEntity>(object userContext, TDbContext data, ClaimsPrincipal? userPrincipal, TEntity input);
```
<sup><a href='/src/GraphQL.EntityFramework/Filters/Filters.cs#L3-L12' title='Snippet source file'>snippet source</a> | <a href='#snippet-FiltersSignature' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Filter Projections

When filters need to access navigation properties or foreign keys that aren't included in the GraphQL query, the library provides projection-based filter overloads. These overloads allow specifying exactly which fields the filter needs, and the library will efficiently query only those fields from the database.

### Why Use Projections?

Without projections, filters receive the entity instance as loaded by the GraphQL query. If the query only selects a few fields (via EF projection), foreign keys and navigation properties may not be populated, making authorization decisions impossible.

**Benefits:**

* **Access to Foreign Keys**: Query foreign key properties even when not requested in the GraphQL query
* **Performance**: Load only the fields needed for filtering, not the entire entity
* **Explicit Dependencies**: Clearly declare what data the filter requires

**Important Requirements:**

* The entity type must have an `Id` property
* The projection is executed as a separate database query using the entity IDs
* The `Id` is automatically included in the database query even if not in the projection

### Usage:

<!-- snippet: projection-filter -->
<a id='snippet-projection-filter'></a>
```cs
public class ChildEntity
{
    public Guid Id { get; set; }
    public Guid? ParentId { get; set; }
    public string? Property { get; set; }
}

public class ChildFilterProjection
{
    public Guid? ParentId { get; set; }
}
```
<sup><a href='/src/Snippets/GlobalFilterSnippets.cs#L46-L60' title='Snippet source file'>snippet source</a> | <a href='#snippet-projection-filter' title='Start of snippet'>anchor</a></sup>
<a id='snippet-projection-filter-1'></a>
```cs
var filters = new Filters<MyDbContext>();
filters.Add<ChildEntity, ChildFilterProjection>(
    projection: child => new()
    {
        ParentId = child.ParentId
    },
    filter: (userContext, data, userPrincipal, projected) =>
    {
        var allowedParentId = GetAllowedParentId(userContext);
        return projected.ParentId == allowedParentId;
    });
EfGraphQLConventions.RegisterInContainer<MyDbContext>(
    services,
    resolveFilters: _ => filters);
```
<sup><a href='/src/Snippets/GlobalFilterSnippets.cs#L64-L81' title='Snippet source file'>snippet source</a> | <a href='#snippet-projection-filter-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

### How It Works:

1. GraphQL query executes and loads entities based on requested fields
2. For each entity, the library extracts the entity ID
3. A separate database query fetches the projected fields (including Id automatically) using those IDs:
   ```sql
   SELECT Id, ParentId
   FROM ChildEntities
   WHERE Id IN (...)
   ```
4. The projected data is passed to the filter function
5. Entities that fail the filter are excluded from results

**Important**: The projection query ensures all needed fields are loaded from the database, regardless of what the GraphQL query selected. This is why projections are required - filters cannot rely on fields being available from the GraphQL query result.

### Filtering on Multiple Fields:

To filter using multiple entity fields, explicitly list all fields in the projection:

<!-- snippet: filter-all-fields -->
<a id='snippet-filter-all-fields'></a>
```cs
public class MyEntityFilter
{
    public string? Property { get; set; }
}
```
<sup><a href='/src/Snippets/GlobalFilterSnippets.cs#L15-L22' title='Snippet source file'>snippet source</a> | <a href='#snippet-filter-all-fields' title='Start of snippet'>anchor</a></sup>
<a id='snippet-filter-all-fields-1'></a>
```cs
var filters = new Filters<MyDbContext>();
filters.Add<MyEntity, MyEntityFilter>(
    projection: entity => new()
    {
        Property = entity.Property
    },
    filter: (userContext, dbContext, userPrincipal, projected) =>
        projected.Property != "Ignore");
EfGraphQLConventions.RegisterInContainer<MyDbContext>(
    services,
    resolveFilters: _ => filters);
```
<sup><a href='/src/Snippets/GlobalFilterSnippets.cs#L26-L40' title='Snippet source file'>snippet source</a> | <a href='#snippet-filter-all-fields-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Value Type Projections

For filtering scenarios where only a single property value needs to be checked, projecting directly to a value type is an option instead of creating a dedicated projection class. This is useful for basic authorization rules or business logic that depends on a single field.

### Supported Value Types:

The filter projection system supports all value types including:

* Primitive types: `string`, `int`, `bool`, `decimal`, `double`, etc.
* Date/time types: `DateTime`, `DateTimeOffset`, `TimeSpan`
* Other value types: `Guid`, enums, custom structs

### Usage:

<!-- snippet: value-type-projections -->
<a id='snippet-value-type-projections'></a>
```cs
public class Product
{
    public Guid Id { get; set; }
    public string? Name { get; set; }
    public int Stock { get; set; }
    public bool IsActive { get; set; }
    public DateTime CreatedAt { get; set; }
}
```
<sup><a href='/src/Snippets/GlobalFilterSnippets.cs#L87-L98' title='Snippet source file'>snippet source</a> | <a href='#snippet-value-type-projections' title='Start of snippet'>anchor</a></sup>
<a id='snippet-value-type-projections-1'></a>
```cs
var filters = new Filters<MyDbContext>();

// Filter using a string property
filters.Add<Product, string>(
    projection: entity => entity.Name!,
    filter: (_, _, _, name) => name != "Discontinued");

// Filter using an int property
filters.Add<Product, int>(
    projection: entity => entity.Stock,
    filter: (_, _, _, stock) => stock > 0);

// Filter using a bool property
filters.Add<Product, bool>(
    projection: entity => entity.IsActive,
    filter: (_, _, _, isActive) => isActive);

// Filter using a DateTime property
filters.Add<Product, DateTime>(
    projection: entity => entity.CreatedAt,
    filter: (_, _, _, createdAt) => createdAt >= new DateTime(2024, 1, 1));

EfGraphQLConventions.RegisterInContainer<MyDbContext>(
    services,
    resolveFilters: _ => filters);
```
<sup><a href='/src/Snippets/GlobalFilterSnippets.cs#L102-L130' title='Snippet source file'>snippet source</a> | <a href='#snippet-value-type-projections-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

### Benefits:

* **Less code**: No need to create projection classes for single-field filters
* **Type safety**: The filter function receives the strongly-typed value
* **Same performance**: Uses the same efficient projection query mechanism
* **Combines with object projections**: Value type and object projections can be mixed in the same filter collection

### When to Use:

* **Single field checks**: Filtering based on one property (status, age, type)
* **Simple comparisons**: Equality, range checks, null checks
* **Quick authorization**: Checking if a single field matches allowed values

### When to Use Object Projections Instead:

* **Multiple fields**: Need to check multiple properties in combination
* **Complex logic**: Filtering requires multiple related values
* **Navigation properties**: Need to access foreign keys or related data
