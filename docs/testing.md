<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /docs/mdsource/testing.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# Testing Filters

Entity filters can be tested directly without running a full GraphQL query. The `Filters<TDbContext>.ShouldInclude` method evaluates registered filters against a single entity instance, returning a boolean result.

This approach is significantly faster than executing GraphQL queries in tests because it bypasses schema compilation, query parsing, and the full GraphQL execution pipeline.


## Signature

<!-- snippet: ShouldIncludeSignature -->
<a id='snippet-ShouldIncludeSignature'></a>
```cs
public async Task<bool> ShouldInclude(
    object userContext,
    TDbContext data,
    ClaimsPrincipal? user,
    object item)
```
<sup><a href='/src/GraphQL.EntityFramework/Filters/Filters.cs#L190-L198' title='Snippet source file'>snippet source</a> | <a href='#snippet-ShouldIncludeSignature' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `userContext` | `object` | The GraphQL user context. Use `new Dictionary<string, object?>()` in tests |
| `data` | `TDbContext` | The `DbContext` instance |
| `user` | `ClaimsPrincipal?` | The user to evaluate filters against |
| `item` | `object` | The entity instance. Navigation properties used by filter projections must be loaded |


## How It Works

1. Uses `item.GetType()` to determine the entity type at runtime
2. Finds all registered filters that apply to that type (including base type filters via `IsAssignableFrom`)
3. For each matching filter, applies the compiled projection expression to the entity
4. Passes the projected data to the filter function
5. Returns `false` as soon as any filter excludes the entity, or `true` if all filters pass


## Usage

<!-- snippet: testing-should-include -->
<a id='snippet-testing-should-include'></a>
```cs
// Build filters
var filters = new Filters<TestDbContext>();
// call the same method used to register filters at startup
RegisterFilters(filters);

var entityId = orderId;

// Load entity from DB
var entity = (await ActData.FindAsync(typeof(Order), entityId))!;

// Load reference navigations needed by filter projections
var entry = ActData.Entry(entity);
foreach (var nav in entry.Navigations)
{
    if (nav is { Metadata: INavigation { IsCollection: false }, IsLoaded: false })
    {
        await nav.LoadAsync();
    }
}

var userContext = new Dictionary<string, object?>();

var result = await filters.ShouldInclude(
    userContext,
    ActData,
    CreateUser(ownerId),
    entity);
// result is true if all filters allow access, false if any filter excludes the entity
```
<sup><a href='/src/Snippets/TestingFilterSnippets.cs#L71-L102' title='Snippet source file'>snippet source</a> | <a href='#snippet-testing-should-include' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Loading Navigation Properties

Filter projections often traverse navigation properties (e.g. `_.Category.Name` or `_.TravelRequest.GroupOwnerId`). When loading an entity with `FindAsync`, these navigations are not populated by default. They must be explicitly loaded before calling `ShouldInclude`, otherwise the projection will see `null` values.

The recommended pattern loads all reference (non-collection) navigations:

```csharp
var entry = dbContext.Entry(entity);
foreach (var nav in entry.Navigations)
{
    if (nav.Metadata is INavigation { IsCollection: false } &&
        !nav.IsLoaded)
    {
        await nav.LoadAsync();
    }
}
```

Notes:

 * Only **reference** navigations (`IsCollection: false`) need loading. Collection navigations are not traversed by filter projections.
 * Some filters perform their own database queries internally (e.g. using `data.Set<T>().Where(...).Select(...)`) and do not rely on navigation properties being pre-loaded.
 * If a filter uses an identity projection (`_ => _`), only key properties are accessed, so no navigation loading is needed.


## Testing Multiple Entities

To test filter behavior across many entity types and user roles, combine `ShouldInclude` with parameterized tests:

```csharp
[Test]
[TestCaseSource(nameof(GetTestCases))]
public async Task Permissions(Type entityType, Guid entityId, ClaimsPrincipal user)
{
    var filters = new Filters<MyDbContext>();
    MyFilters.AddFilters(filters);

    var entity = await dbContext.FindAsync(entityType, entityId);

    // load navigations...

    var result = await filters.ShouldInclude(
        new Dictionary<string, object?>(),
        dbContext,
        user,
        entity!);

    await Verify(result);
}
```

This avoids the overhead of compiling a GraphQL schema and building a service provider for each test case.
